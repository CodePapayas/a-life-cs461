/*
 *  Dillon Stickler - Oregon State University - 2026
 */

#pragma once
#ifndef PERLINNOISE_H
#define PERLINNOISE_H

#include <cmath>
#include <iostream>
#include <stdlib.h>
#include <stdio.h>
#include <vector>
#include <fstream>
#include <cstring>
#include <time.h>
#include "MathVector.hpp"

/* 
   Perlin Noise function, 
   adapted from Ken Perlin's "JAVA REFERENCE IMPLEMENTATION OF IMPROVED NOISE",
   https://cs.nyu.edu/~perlin/noise/
   and Raouf Touti's adaptation of Ken Perlin's function,
   https://rtouti.github.io/graphics/perlin-noise-algorithm
*/
class PerlinNoise2d{
	private:
		std::vector<double> p;	// permutation table- noise is generated by sampling this, ensuring deterministic pseudo-random results.
		int p_table_size = 256;	// permutation table size

		int octaves = 8;		// octaves of detail; how granular is the noise
		double frequency = 1;	// initial frequency- or scale- of the noise; how "zoomed in" is it
		double amplitude = 1;	// initial amplitude; how contrasted is the noise, smoothed or sharp?
		
	public:		
		double lerp(double a1, double a2, double t) {
			// linearly interpolate (lerp) between 'a1' and 'a2', over value 't'. 
			// As t approaches 1.0, the value returned approaches a2.
			return (a1 + t * (a2 - a1));
		}	
		double fade(double t) 	{
			// fade the value, t, to get a more gradual transition between values, a smoother noise result later.
			return ((6.0 * t - 15.0) * t + 10.0) * t * t * t ;
		} 
		
		void shuffle(){
			// Input: vector<double> p
			// Output: vector<double> p
			// Takes permutation table "p" and utilizes rand() to "shuffle" the order.
			int shuffle_times = 1;		// number of times we want to shuffle the table
			for(int s = 0; s < shuffle_times; s++){		// shuffle the desired number of times
				for(int i = p.size()-1; i > 0; i--){	// work backwards through the permutation table.
					int index = round(rand() * i-1);	// get a random value, adjusted to a different relative position
					if(index < 0){std::cout << "ERROR OUT OF BOUNDS" << std::endl;}
					index = index % p.size(); 			// ensure the index does not exceed the bounds of the permutation table
					double temp = p[i];					// swap the values
					p[i] = p[index];					
					p[index] = temp;					
				}
			}
		}
		
		void makePermutation(){
			// Input: vector<double> p
			// Output: vector<double> p
			// Generates the list of permutation values for the noise to sample from.
			// If a custom "p" is utilized instead of this function, the noise will be unchanged each run, like it was "seeded".

			std::cout << "Generating permutation table...\n";

			// generate a list of valuese from [0, p_table_size)
			for(int i = 0; i < p_table_size; i++){
				p.push_back((double)i);
			}
			// shuffle the list
			shuffle();
			
			// duplicate the shuffled values in order, extending the permutation table to be 2(p_table_size)
			for(int i = 0; i < p_table_size; i++){
				p.push_back(p[i]);
			}
		}

		Vector2d toConstantVector(double v){
			// Input: double v
			// Output: Vector2d constant_vector
			// Takes in double value "v", evaluates the value to get a constant vector which determines the direction of the noise from the value.
			int h = (int)fmod(v, 4.0);
			switch (h){
				case 0:
					return Vector2d(1.0, 1.0);
				case 1:
					return Vector2d(-1.0, 1.0);
				case 2:
					return Vector2d(-1.0, -1.0);
				case 3:
					return Vector2d(1.0, -1.0);
				default:
					return Vector2d(0.0, 0.0);
			}
		}
		
		double SampleNoiseBase(double x, double y){
			// Input: double x, double y
			// Output: double result
			// Returns the basic, unchanged noise value at position (x, y). 

			// Due to the nature of this noise generation method, we treat x and y as integer coordinates of a cell.
			// The decimal component is the current "progress" across the cell, meaning that integer (x,y) values like (1.0, 2.0)
			// don't return a proper value as the noise regards it as if we haven't gone anywhere.
			// A.k.a. it will act weird.
			x = x * (1.1);
			y = y * (1.1);

			// Get 
			int X = x;
			X = X % p_table_size;
			int Y = y;
			Y = Y % p_table_size;

			// Get decimal component of x,y
			double xf = x - floor(x);
			double yf = y - floor(y);

			// Get corner positions of current cell
			Vector2d tr_v = Vector2d(xf - 1.0, yf - 1.0);
			Vector2d tl_v = Vector2d(xf, yf - 1.0);
			Vector2d br_v = Vector2d(xf - 1.0, yf);
			Vector2d bl_v = Vector2d(xf, yf);

			// Get values for each corner from permutation table.
			double val_tr = p[p[X + 1] + Y + 1];
			double val_tl = p[p[X] + Y + 1];
			double val_br = p[p[X + 1] + Y];
			double val_bl = p[p[X] + Y];

			// Convert the values to vectors to get their "direction", and get the dot between that and the current position.
			double dot_tr = tr_v.dot(toConstantVector(val_tr));
			double dot_tl = tl_v.dot(toConstantVector(val_tl));
			double dot_br = br_v.dot(toConstantVector(val_br));
			double dot_bl = bl_v.dot(toConstantVector(val_bl));

			// Fade the decimal to get a more gradual transition between values with the result
			double u = fade(xf);	
			double v = fade(yf);

			// Lerp from bottom to top over V, from left to right over U, to get the noise result at (x,y)
			double result = lerp(lerp(dot_bl, dot_tl, v),lerp( dot_br, dot_tr, v), u);
			return result;
		}
		
		double SampleNoiseLayered(Vector2d pos){
			// Input: Vector2d pos
			// Output: double result
			// Samples noise 'o' number of times from SampleNoiseBase, at double the previous frequency and half the previous amplitude with each octave.
			// Adds the samples over all octaves and returns the sum, after repeating for 'o' octaves.
			// In simpler terms, we sample the noise at (x,y), zoom out, and sample a subtler value, repeating for 'o' octaves to get a more 'detailed' or noisy result.
			double curr_sample 	= 0;
			double curr_freq 	= frequency;
			double curr_amp 	= amplitude;
			for(int o = 1; o < octaves; o++){
				curr_sample += curr_amp * SampleNoiseBase(curr_freq * pos.x, curr_freq * pos.y);
				curr_amp *= 0.5;
				curr_freq *= 2.0;
			}
			return curr_sample;
		}

		void SetOctaves(int o)		{octaves = o;}
		void SetFrequency(double f)	{frequency = f;}
		void SetAmplitude(double a)	{amplitude = a;}

		PerlinNoise2d(){makePermutation();}
};

#endif